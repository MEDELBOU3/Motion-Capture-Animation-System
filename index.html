<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Advanced Motion Capture with Soldier Character</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); 
      font-family: 'Arial', sans-serif;
    }
    video { display: none; }
    canvas { position: absolute; top: 0; left: 0; }
    
    .ui-overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      z-index: 100;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 10px;
      backdrop-filter: blur(10px);
      max-width: 300px;
    }

    .debug-overlay {
      position: absolute;
      top: 20px;
      right: 20px;
      color: white;
      z-index: 100;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 10px;
      backdrop-filter: blur(10px);
      max-width: 250px;
      font-size: 12px;
    }

    .help-tips {
      position: absolute;
      bottom: 80px;
      left: 20px;
      color: white;
      z-index: 100;
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border-radius: 10px;
      max-width: 300px;
      font-size: 13px;
      border-left: 4px solid #4ecdc4;
    }
    
    .status {
      margin: 5px 0;
      padding: 5px 10px;
      border-radius: 5px;
      background: rgba(255,255,255,0.1);
      font-size: 14px;
    }
    
    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 18px;
      text-align: center;
      z-index: 200;
      background: rgba(0,0,0,0.8);
      padding: 30px;
      border-radius: 15px;
      max-width: 400px;
    }
    
    .controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
    }
    
    button {
      margin: 0 5px;
      padding: 10px 20px;
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      border-radius: 5px;
      cursor: pointer;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }
    
    button:hover {
      background: rgba(255,255,255,0.3);
      transform: scale(1.05);
    }

    .error {
      color: #ff6b6b;
      background: rgba(255, 107, 107, 0.1);
      border: 1px solid rgba(255, 107, 107, 0.3);
    }

    .success {
      color: #4ecdc4;
      background: rgba(78, 205, 196, 0.1);
      border: 1px solid rgba(78, 205, 196, 0.3);
    }
  </style>
</head>
<body>

<div class="loading" id="loadingScreen">
  <div>üé≠ Initializing Motion Capture System...</div>
  <div style="margin-top: 15px; font-size: 14px;">
    <div id="loadingStep">Setting up camera access...</div>
    <div style="margin-top: 10px; font-size: 12px; opacity: 0.8;">Please allow camera permissions when prompted</div>
  </div>
</div>

<div class="debug-overlay" id="debugOverlay" style="display: none;">
  <div><strong>üìä Debug Info</strong></div>
  <div>Video Size: <span id="videoSize">-</span></div>
  <div>FPS: <span id="fps">-</span></div>
  <div>Last Detection: <span id="lastDetection">-</span></div>
  <div>Confidence: <span id="confidence">-</span></div>
  <div>Character Bones: <span id="boneCount">-</span></div>
</div>

<div class="help-tips" id="helpTips">
  <div><strong>üí° Tips for Better Detection:</strong></div>
  <div>‚Ä¢ Stand 3-6 feet from camera</div>
  <div>‚Ä¢ Ensure good lighting</div>
  <div>‚Ä¢ Keep full body in frame</div>
  <div>‚Ä¢ Avoid busy backgrounds</div>
  <div>‚Ä¢ Move slowly at first</div>
</div>

<div class="ui-overlay" id="uiOverlay" style="display: none;">
  <div class="status" id="cameraStatusDiv">üìπ Camera: <span id="cameraStatus">Starting...</span></div>
  <div class="status" id="modelStatusDiv">ü§ñ AI Model: <span id="modelStatus">Loading...</span></div>
  <div class="status" id="characterStatusDiv">üë§ Character: <span id="characterStatus">Loading...</span></div>
  <div class="status" id="poseStatusDiv">üéØ Pose: <span id="poseStatus">Waiting...</span></div>
</div>

<div class="controls" id="controls" style="display: none;">
  <button onclick="toggleCharacterVisibility()">Toggle Character</button>
  <button onclick="toggleSkeleton()">Toggle Skeleton</button>
  <button onclick="resetCharacterPose()">Reset Pose</button>
  <button onclick="toggleDebug()">Debug Info</button>
  <button onclick="toggleVideoPreview()">Show Camera</button>
</div>

<video id="video" width="640" height="480" autoplay playsinline muted></video>

<!-- Load Three.js first -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/animation/AnimationClip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/animation/AnimationMixer.min.js"></script>

<!-- Then TensorFlow -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

<script>
// Global variables
let video = document.getElementById('video');
let scene, camera, renderer, controls;
let detector;
let skeleton = {};
let character = null;
let mixer = null;
let characterBones = {};
let showCharacter = true;
let showSkeleton = true;
let isInitialized = false;
let animationId = null;
let showDebug = false;
let showVideoPreview = false;
let frameCount = 0;
let lastTime = performance.now();
let currentFPS = 0;

// UI elements
const loadingScreen = document.getElementById('loadingScreen');
const loadingStep = document.getElementById('loadingStep');
const uiOverlay = document.getElementById('uiOverlay');
const debugOverlay = document.getElementById('debugOverlay');
const helpTips = document.getElementById('helpTips');
const controlsDiv = document.getElementById('controls');
const cameraStatus = document.getElementById('cameraStatus');
const modelStatus = document.getElementById('modelStatus');
const characterStatus = document.getElementById('characterStatus');
const poseStatus = document.getElementById('poseStatus');

// Utility function to update status with styling
function updateStatus(element, statusElement, message, type = 'normal') {
  statusElement.textContent = message;
  element.className = 'status';
  if (type === 'error') element.classList.add('error');
  if (type === 'success') element.classList.add('success');
}

// Initialize webcam with better error handling
async function initWebcam() {
  try {
    loadingStep.textContent = 'Requesting camera access...';
    updateStatus(document.getElementById('cameraStatusDiv'), cameraStatus, 'Requesting access...');

    // Check if getUserMedia is supported
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      throw new Error('Camera API not supported in this browser');
    }

    const constraints = {
      video: {
        width: { ideal: 640, min: 320 },
        height: { ideal: 480, min: 240 },
        facingMode: 'user',
        frameRate: { ideal: 30, min: 15 }
      }
    };

    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;

    return new Promise((resolve, reject) => {
      video.onloadedmetadata = () => {
        loadingStep.textContent = 'Camera ready!';
        updateStatus(document.getElementById('cameraStatusDiv'), cameraStatus, '‚úÖ Active', 'success');
        resolve();
      };
      video.onerror = () => {
        reject(new Error('Failed to load video stream'));
      };
      
      // Timeout after 10 seconds
      setTimeout(() => {
        reject(new Error('Camera initialization timeout'));
      }, 10000);
    });
  } catch (error) {
    updateStatus(document.getElementById('cameraStatusDiv'), cameraStatus, '‚ùå Failed', 'error');
    throw new Error(`Camera Error: ${error.message}`);
  }
}

// Load Soldier character model
async function loadSoldierCharacter() {
  return new Promise((resolve, reject) => {
    const loader = new THREE.GLTFLoader();
    const soldierUrl = 'https://threejs.org/examples/models/gltf/Soldier.glb';
    
    loader.load(
      soldierUrl,
      function (gltf) {
        const model = gltf.scene;
        
        // Scale and position the model
        model.scale.set(0.5, 0.5, 0.5);
        model.position.set(0, -1.5, 0);
        
        // Create animation mixer
        mixer = new THREE.AnimationMixer(model);
        
        // Play all animations (we'll override them with our motion capture)
        gltf.animations.forEach((clip) => {
          const action = mixer.clipAction(clip);
          action.play();
        });
        
        // Traverse the model to find bones
        model.traverse((node) => {
          if (node.isBone) {
            characterBones[node.name] = node;
          }
        });
        
        // Store animations
        model.animations = gltf.animations;
        
        // Add to scene
        scene.add(model);
        
        // Count bones for debug info
        if (showDebug) {
          document.getElementById('boneCount').textContent = Object.keys(characterBones).length;
        }
        
        resolve(model);
      },
      undefined,
      function (error) {
        reject(new Error(`Failed to load character: ${error.message}`));
      }
    );
  });
}

// Create skeleton bone
function createBone(name, color = 0x00ff00) {
  const material = new THREE.LineBasicMaterial({ 
    color, 
    transparent: true,
    opacity: 0.8
  });
  const geometry = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)
  ]);
  const line = new THREE.Line(geometry, material);
  line.name = name;
  return line;
}

// Connect two joints
function connect(joints, a, b) {
  const ja = joints[a];
  const jb = joints[b];
  if (ja && jb && ja.score > 0.3 && jb.score > 0.3) {
    return [
      new THREE.Vector3((ja.x / 100 - 3.2) * 1.5, (-ja.y / 100 + 2.4) * 1.5, 0), 
      new THREE.Vector3((jb.x / 100 - 3.2) * 1.5, (-jb.y / 100 + 2.4) * 1.5, 0)
    ];
  }
  return null;
}

// Update skeleton visualization
function updateSkeleton(joints) {
  const connections = [
    ['left_shoulder', 'right_shoulder'],
    ['left_shoulder', 'left_elbow'],
    ['left_elbow', 'left_wrist'],
    ['right_shoulder', 'right_elbow'],
    ['right_elbow', 'right_wrist'],
    ['left_hip', 'right_hip'],
    ['left_shoulder', 'left_hip'],
    ['right_shoulder', 'right_hip'],
    ['left_hip', 'left_knee'],
    ['left_knee', 'left_ankle'],
    ['right_hip', 'right_knee'],
    ['right_knee', 'right_ankle']
  ];

  for (const [a, b] of connections) {
    const name = a + '_' + b;
    let bone = skeleton[name];
    if (!bone) {
      bone = createBone(name, 0x00ffff);
      scene.add(bone);
      skeleton[name] = bone;
    }

    bone.visible = showSkeleton;

    const pts = connect(joints, a, b);
    if (pts) {
      const positions = bone.geometry.attributes.position.array;
      positions[0] = pts[0].x; positions[1] = pts[0].y; positions[2] = pts[0].z;
      positions[3] = pts[1].x; positions[4] = pts[1].y; positions[5] = pts[1].z;
      bone.geometry.attributes.position.needsUpdate = true;
    }
  }
}

// Map pose detection keypoints to character bones
function updateCharacterPose(joints) {
  if (!character || !showCharacter) return;

  function getJoint(name) {
    const joint = joints[name];
    return joint && joint.score > 0.3 ? joint : null;
  }

  // Helper function to calculate angle between joints
  function calculateAngle(joint1, joint2) {
    return Math.atan2(joint2.y - joint1.y, joint2.x - joint1.x);
  }

  // Get keypoints
  const nose = getJoint('nose');
  const leftShoulder = getJoint('left_shoulder');
  const rightShoulder = getJoint('right_shoulder');
  const leftElbow = getJoint('left_elbow');
  const rightElbow = getJoint('right_elbow');
  const leftWrist = getJoint('left_wrist');
  const rightWrist = getJoint('right_wrist');
  const leftHip = getJoint('left_hip');
  const rightHip = getJoint('right_hip');
  const leftKnee = getJoint('left_knee');
  const rightKnee = getJoint('right_knee');
  const leftAnkle = getJoint('left_ankle');
  const rightAnkle = getJoint('right_ankle');

  // Update head rotation based on nose position
  if (nose && characterBones['Head']) {
    // Simple head tracking - could be enhanced
    characterBones['Head'].rotation.y = (nose.x / video.videoWidth - 0.5) * 0.5;
    characterBones['Head'].rotation.x = (0.5 - nose.y / video.videoHeight) * 0.3;
  }

  // Update arms with smooth transitions
  if (leftShoulder && leftElbow && characterBones['LeftArm']) {
    const angle = calculateAngle(leftShoulder, leftElbow);
    THREE.MathUtils.lerp(characterBones['LeftArm'].rotation.z, angle + Math.PI/2, 0.2);
  }

  if (rightShoulder && rightElbow && characterBones['RightArm']) {
    const angle = calculateAngle(rightShoulder, rightElbow);
    THREE.MathUtils.lerp(characterBones['RightArm'].rotation.z, angle + Math.PI/2, 0.2);
  }

  if (leftElbow && leftWrist && characterBones['LeftForeArm']) {
    const angle = calculateAngle(leftElbow, leftWrist);
    THREE.MathUtils.lerp(characterBones['LeftForeArm'].rotation.z, angle + Math.PI/2, 0.2);
  }

  if (rightElbow && rightWrist && characterBones['RightForeArm']) {
    const angle = calculateAngle(rightElbow, rightWrist);
    THREE.MathUtils.lerp(characterBones['RightForeArm'].rotation.z, angle + Math.PI/2, 0.2);
  }

  // Update legs with smooth transitions
  if (leftHip && leftKnee && characterBones['LeftUpLeg']) {
    const angle = calculateAngle(leftHip, leftKnee);
    THREE.MathUtils.lerp(characterBones['LeftUpLeg'].rotation.z, angle + Math.PI/2, 0.2);
  }

  if (rightHip && rightKnee && characterBones['RightUpLeg']) {
    const angle = calculateAngle(rightHip, rightKnee);
    THREE.MathUtils.lerp(characterBones['RightUpLeg'].rotation.z, angle + Math.PI/2, 0.2);
  }

  if (leftKnee && leftAnkle && characterBones['LeftLeg']) {
    const angle = calculateAngle(leftKnee, leftAnkle);
    THREE.MathUtils.lerp(characterBones['LeftLeg'].rotation.z, angle + Math.PI/2, 0.2);
  }

  if (rightKnee && rightAnkle && characterBones['RightLeg']) {
    const angle = calculateAngle(rightKnee, rightAnkle);
    THREE.MathUtils.lerp(characterBones['RightLeg'].rotation.z, angle + Math.PI/2, 0.2);
  }

  // Update spine based on shoulder positions with smooth transitions
  if (leftShoulder && rightShoulder && characterBones['Spine2']) {
    const shoulderCenterX = (leftShoulder.x + rightShoulder.x) / 2;
    const shoulderCenterY = (leftShoulder.y + rightShoulder.y) / 2;
    const tilt = (rightShoulder.y - leftShoulder.y) / 100;
    
    THREE.MathUtils.lerp(characterBones['Spine2'].rotation.z, tilt * 0.5, 0.1);
    THREE.MathUtils.lerp(characterBones['Spine1'].rotation.z, tilt * 0.3, 0.1);
    THREE.MathUtils.lerp(characterBones['Spine'].rotation.z, tilt * 0.2, 0.1);
  }

  character.visible = showCharacter;
}

// Pose detection with enhanced sensitivity
async function detectPose() {
  if (!detector || !isInitialized || !video.videoWidth) return;

  try {
    // Update debug info
    if (showDebug) {
      document.getElementById('videoSize').textContent = `${video.videoWidth}√ó${video.videoHeight}`;
      
      // Calculate FPS
      frameCount++;
      const now = performance.now();
      if (now - lastTime >= 1000) {
        currentFPS = Math.round((frameCount * 1000) / (now - lastTime));
        document.getElementById('fps').textContent = currentFPS;
        frameCount = 0;
        lastTime = now;
      }
    }

    const poses = await detector.estimatePoses(video, {
      maxPoses: 1,
      flipHorizontal: false,
      scoreThreshold: 0.15,  // Lower threshold for better detection
      nmsRadius: 20
    });

    if (poses.length > 0) {
      const keypoints = poses[0].keypoints;
      const joints = {};
      let validPoints = 0;
      let totalConfidence = 0;
      
      keypoints.forEach(kp => {
        if (kp.score > 0.15) {  // Lower confidence threshold
          joints[kp.name] = { 
            x: kp.x, 
            y: kp.y, 
            score: kp.score
          };
          validPoints++;
          totalConfidence += kp.score;
        }
      });
      
      const avgConfidence = totalConfidence / validPoints;
      
      if (validPoints >= 5) {  // Need at least 5 visible points
        updateSkeleton(joints);
        updateCharacterPose(joints);
        updateStatus(document.getElementById('poseStatusDiv'), poseStatus, `‚úÖ Active (${validPoints}/17 points)`, 'success');
        
        if (showDebug) {
          document.getElementById('lastDetection').textContent = new Date().toLocaleTimeString();
          document.getElementById('confidence').textContent = (avgConfidence * 100).toFixed(1) + '%';
        }
        
        // Hide help tips after successful detection
        if (helpTips.style.display !== 'none') {
          setTimeout(() => {
            helpTips.style.display = 'none';
          }, 3000);
        }
      } else {
        updateStatus(document.getElementById('poseStatusDiv'), poseStatus, `‚ö†Ô∏è Partial detection (${validPoints}/17 points)`);
        helpTips.style.display = 'block';
      }
    } else {
      updateStatus(document.getElementById('poseStatusDiv'), poseStatus, '‚ö†Ô∏è No pose detected');
      helpTips.style.display = 'block';
      
      if (showDebug) {
        document.getElementById('confidence').textContent = '0%';
      }
    }
  } catch (error) {
    updateStatus(document.getElementById('poseStatusDiv'), poseStatus, '‚ùå Detection error', 'error');
    console.error('Pose detection error:', error);
  }
}

// Animation loop
function animate() {
  animationId = requestAnimationFrame(animate);
  
  if (isInitialized && detector) {
    detectPose();
  }
  
  // Update animation mixer
  if (mixer) {
    mixer.update(0.016); // Update with delta time
  }
  
  // Update controls
  if (controls) {
    controls.update();
  }
  
  if (renderer && scene && camera) {
    renderer.render(scene, camera);
  }
}

// Control functions
function toggleCharacterVisibility() {
  showCharacter = !showCharacter;
  if (character) {
    character.visible = showCharacter;
  }
}

function toggleSkeleton() {
  showSkeleton = !showSkeleton;
  Object.values(skeleton).forEach(bone => {
    bone.visible = showSkeleton;
  });
}

function resetCharacterPose() {
  if (!character) return;
  
  Object.values(characterBones).forEach(bone => {
    bone.rotation.set(0, 0, 0);
  });
}

function toggleDebug() {
  showDebug = !showDebug;
  debugOverlay.style.display = showDebug ? 'block' : 'none';
}

function toggleVideoPreview() {
  showVideoPreview = !showVideoPreview;
  video.style.display = showVideoPreview ? 'block' : 'none';
  video.style.position = 'fixed';
  video.style.top = '20px';
  video.style.right = '280px';
  video.style.width = '160px';
  video.style.height = '120px';
  video.style.zIndex = '150';
  video.style.border = '2px solid #4ecdc4';
  video.style.borderRadius = '5px';
}

// Main initialization
async function main() {
  try {
    // Step 1: Initialize webcam
    loadingStep.textContent = 'Initializing camera...';
    await initWebcam();

    // Step 2: Wait for TensorFlow to be ready
    loadingStep.textContent = 'Loading AI models...';
    updateStatus(document.getElementById('modelStatusDiv'), modelStatus, 'Loading...');
    
    // Wait for tf to be available
    let attempts = 0;
    while (typeof tf === 'undefined' && attempts < 50) {
      await new Promise(resolve => setTimeout(resolve, 100));
      attempts++;
    }

    if (typeof tf === 'undefined') {
      throw new Error('TensorFlow.js failed to load');
    }

    await tf.ready();

    // Step 3: Load pose detection model
    detector = await poseDetection.createDetector(
      poseDetection.SupportedModels.MoveNet,
      {
        modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
      }
    );
    updateStatus(document.getElementById('modelStatusDiv'), modelStatus, '‚úÖ Ready', 'success');

    // Step 4: Initialize THREE.js scene
    loadingStep.textContent = 'Creating 3D scene...';
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.5, 5);
    camera.lookAt(0, 1, 0);

    renderer = new THREE.WebGLRenderer({ 
      antialias: true,
      alpha: true 
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // Add orbit controls
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.maxPolarAngle = Math.PI * 0.9;
    controls.minDistance = 2;
    controls.maxDistance = 10;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 10, 5);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;
    scene.add(directionalLight);

    const pointLight = new THREE.PointLight(0x00ffff, 0.5, 100);
    pointLight.position.set(-5, 5, 5);
    scene.add(pointLight);

    // Ground
    const groundGeometry = new THREE.PlaneGeometry(20, 20);
    const groundMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x333333,
      roughness: 0.8,
      metalness: 0.2
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -1.5;
    ground.receiveShadow = true;
    scene.add(ground);

    // Grid helper
    const gridHelper = new THREE.GridHelper(20, 20, 0x555555, 0x333333);
    scene.add(gridHelper);

    // Step 5: Load character
    loadingStep.textContent = 'Loading soldier character...';
    updateStatus(document.getElementById('characterStatusDiv'), characterStatus, 'Loading...');
    character = await loadSoldierCharacter();
    
    // Enable shadows for character
    character.traverse((node) => {
      if (node.isMesh) {
        node.castShadow = true;
        node.receiveShadow = true;
      }
    });
    
    updateStatus(document.getElementById('characterStatusDiv'), characterStatus, '‚úÖ Ready', 'success');

    // Handle window resize
    window.addEventListener('resize', () => {
      if (camera && renderer) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    });

    // Step 6: Finalize
    loadingStep.textContent = 'Starting motion capture...';
    loadingScreen.style.display = 'none';
    uiOverlay.style.display = 'block';
    controlsDiv.style.display = 'block';

    isInitialized = true;
    animate();

  } catch (error) {
    console.error('Initialization error:', error);
    loadingScreen.innerHTML = `
      <div style="color: #ff6b6b;">‚ùå Initialization Failed</div>
      <div style="margin-top: 15px; font-size: 14px;">${error.message}</div>
      <div style="margin-top: 15px; font-size: 12px; opacity: 0.8;">
        Troubleshooting tips:<br>
        ‚Ä¢ Make sure camera permissions are allowed<br>
        ‚Ä¢ Try refreshing the page<br>
        ‚Ä¢ Use a modern browser (Chrome, Firefox, Edge)<br>
        ‚Ä¢ Ensure stable internet connection for AI models
      </div>
    `;
  }
}

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  if (animationId) {
    cancelAnimationFrame(animationId);
  }
  if (video.srcObject) {
    video.srcObject.getTracks().forEach(track => track.stop());
  }
});

// Start the application
main();

</script>
</body>
</html>
